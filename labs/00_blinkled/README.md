## Описание лабораторной работы
### Подготовка
Для программирования микроконтроллера необходмио установить минимальный набор программ - toolchain. Инструкция для установки toolchain под Linux находится [здесь](../../Toolchain-installation.md).

Перед началом работы с микронотроллером необходимо просмотреть документацию по нему. В этой лабораторной работе мы будем работать только с двумя документами:
- [stm32f0discovery](docs/stm32f0discovery.pdf) - описание отладочной платы.
- [stm32f0xx_rm](docs/stm32f0xx_rm.pdf) - полное описание памяти и переферии микроконтроллера STM32.

Документы снабжены комментариями, чтобы вам удобнее было ориентироваться по ним. Список всех комментарии можно посмотреть, например, в программе Adobe Acrobat Reader. Подойдет бесплатная десктопная версия или онлайн-версия.

### Запуск кода на QEMU
В данном репозитории находится код, который мигает светодиодом. Перед тем погружением в в файлы репозиторий и их изучения, убедимся в том, что код работает. Для этого запустим его в среде моделирования QEMU.

TODO Напишите туториал по запуске кода в QEMU. Я не могу, так как у меня винда

### Описание файлов в репозитории
Для понимания процесса сборки файлов настоятельно рекомендуем посмотреть [данное видео](https://youtu.be/qWqlkCLmZoE?t=678). После просмотра вы поймете зачем нужный .c, .s, .o, .lds  файлы и как из кода С получается исполняемый файл для микроконтроллера.

Теперь приступим к описанию файлов в репозитории:
- [Makefile](Makefile) - файл для сборки проекта;
- [blinkled.c](blinkled.c) - тот самый код на Си, который мигает светодиодами;
- [entry.S](entry.S) - код на языке ассемблер, который выполняется до функции main, мы рассмотрим его подробно ниже;
- [entry.lds](entry.lds) - линкер-скрипт - определяет как в конечной программе должны располагаться секции, мы рассмотрим его подробно ниже.

### Описание процесса сборки
Описание синтаксиса Makefile выходит за рамки данного курса. Если вы не знакомы с синтаксисом Makefile, то рекомендуем [данное видео](https://youtu.be/Bsq6P1B8JqI).

Давайте соберем наш проект и создадим исполняемый файл. Для начала создадим папку build:
```
mkdir build
```
Теперь сгенерируем объектный файл из ассемблерного [entry.S](entry.S):
```
arm-none-eabi-gcc -march=armv6-m -mcpu=cortex-m0 -o build/entry.o -c entry.S
```
`arm-none-eabi-gcc` - комплитор, а `-march=armv6-m -mcpu=cortex-m0` - флаги, который указывают на то, что мы собираем код для ARM процессора с ядром cortex-m0. 
Теперь создадим объектный файл из [blinkled.c](blinkled.c):
```
arm-none-eabi-gcc -march=armv6-m -mcpu=cortex-m0 -o build/blinkled.o -c blinkled.c
```
И осталось создать исполняемый .elf файл:
```
arm-none-eabi-gcc -nostdlib -march=armv6-m -mcpu=cortex-m0 -Wl,-T,entry.lds build/entry.o build/blinkled.o -o build/blinkled.elf
```
Смысл фалага `-nostdlib` можно посмотреть [в документации gnu](https://gcc.gnu.org/onlinedocs/gcc-4.4.7/gcc/Link-Options.html#:~:text=option%20is%20specified.-,%2Dnostdlib,used%20to%20ensure%20C%2B%2B%20constructors%20will%20be%20called%3B%20see%20collect2.),-%2Dpie). Флаг `-Wl,-T,entry.lds` передает линкеру линкер-скрипт, согласно которому линкер должен будет разместить секции.

Последний шаг. Создадим файл, который можно будет загрузить в микроконтроллер:
```
arm-none-eabi-objcopy -O binary build/blinkled.elf build/blinkled.bin
```
Готово! Чтобы не писать всё это при каждом измении проекты как раз и нужен Makefile. Вместо всех этих строчек можно написать `make`. Чтобы удалить все исполняемые файлы достаточно исполнить `make clean`.

### Описание entry.S
[entry.S](entry.S) - определяет код, который будет исполняться до функции main. В этой лабораторной работе он довольно простой, но дальше он будет усложняться. Давайте разберём его step-by-step.

```assembly
.syntax unified

.section .text

.thumb_func
.global __reset_handler
__reset_handler:
    blx main
__halt:
	b __halt

.section .vector_table
.word __stack_start    // Initial SP
.word __reset_handler  // Reset Handler
```


## Задачи к лабораторной №0
- [ ] Отрефакторить код (*в эмуляторе*):
	- [ ] В любой момент времени должно быть понятно, в какой бит какого регистра осуществляется запись.
	- [ ] Реализовать дефайны для всех бит регистров (см. документацию на микроконтроллер).
	- [ ] Реализовать макросы для записи значений в регистры.
- [ ] Моргать попеременно синим и зелёным диодами.
- [ ] Отправить сигнал SOS азбукой морзе с диода.
- [ ] Со **звездой**: **Написать на ARM ассемблере timing-perfect delay. Доказать, что он точный, ссылаясь на документацию.** (*на железе*)
