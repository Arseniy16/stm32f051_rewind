## Подготовка
Для программирования микроконтроллера необходимо установить минимальный набор программ - toolchain. Инструкция для установки toolchain под Linux находится [здесь](../../Toolchain-installation.md).

Перед началом работы с микроконтроллером необходимо просмотреть документацию по нему. В этой лабораторной работе мы будем работать только с двумя документами:
- [stm32f0discovery](docs/stm32f0discovery.pdf) - описание отладочной платы.
- [stm32f0xx_rm](docs/stm32f0xx_rm.pdf) - полное описание памяти и периферии микроконтроллера STM32.

Документы снабжены комментариями, чтобы вам удобнее было ориентироваться по ним. Список всех комментарии можно посмотреть, например, в программе Adobe Acrobat Reader. Подойдет бесплатная десктопная версия или онлайн-версия. В онлайн-версии список всех комментариев выглядит вот так:

![imgs/comments.png](imgs/comments.png)

### Запуск кода на QEMU
В данном репозитории находится код, который мигает светодиодом. Перед тем погружением в файлы репозиторий и их изучения, убедимся в том, что код работает. Для этого запустим его в среде моделирования QEMU.

TODO Напишите туториал по запуске кода в QEMU. Я не могу, так как у меня винда

## Описание файлов в репозитории
Для понимания процесса сборки файлов настоятельно рекомендуем посмотреть [данное видео](https://youtu.be/qWqlkCLmZoE?t=678). После просмотра вы поймете зачем нужный .c, .s, .o, .lds  файлы и как из кода Си получается исполняемый файл для микроконтроллера.

Теперь приступим к описанию файлов в репозитории:
- [Makefile](Makefile) - файл для сборки проекта;
- [blinkled.c](blinkled.c) - тот самый код на Си, который мигает светодиодами;
- [entry.S](entry.S) - код на языке ассемблер, который выполняется до функции main, мы рассмотрим его подробно ниже;
- [entry.lds](entry.lds) - линкер-скрипт - определяет как в конечной программе должны располагаться секции, мы рассмотрим его подробно ниже.

## Описание процесса сборки
Описание синтаксиса Makefile выходит за рамки данного курса. Если вы не знакомы с синтаксисом Makefile, то рекомендуем [данное видео](https://youtu.be/Bsq6P1B8JqI).

Давайте соберем наш проект и создадим исполняемый файл. Для начала создадим папку build:
```
mkdir build
```
Теперь сгенерируем объектный файл из ассемблерного [entry.S](entry.S):
```
arm-none-eabi-gcc -march=armv6-m -mcpu=cortex-m0 -o build/entry.o -c entry.S
```
`arm-none-eabi-gcc` - компилятор, а `-march=armv6-m -mcpu=cortex-m0` - флаги, которые указывают на то, что мы собираем код для ARM процессора с ядром cortex-m0. 
Теперь создадим объектный файл из [blinkled.c](blinkled.c):
```
arm-none-eabi-gcc -march=armv6-m -mcpu=cortex-m0 -o build/blinkled.o -c blinkled.c
```
И осталось создать исполняемый .elf файл:
```
arm-none-eabi-gcc -nostdlib -march=armv6-m -mcpu=cortex-m0 -Wl,-T,entry.lds build/entry.o build/blinkled.o -o build/blinkled.elf
```
Смысл флага `-nostdlib` можно посмотреть [в документации gnu](https://gcc.gnu.org/onlinedocs/gcc-4.4.7/gcc/Link-Options.html#:~:text=option%20is%20specified.-,%2Dnostdlib,used%20to%20ensure%20C%2B%2B%20constructors%20will%20be%20called%3B%20see%20collect2.). Флаг `-Wl,-T,entry.lds` передает линкеру скрипт, согласно которому линкер должен будет разместить секции.

Последний шаг. Создадим файл, который можно будет загрузить в микроконтроллер:
```
arm-none-eabi-objcopy -O binary build/blinkled.elf build/blinkled.bin
```
Готово! Чтобы не писать всё это при каждом изменении проекты как раз и нужен Makefile. Вместо всех этих строчек можно написать `make`. Чтобы удалить все исполняемые файлы, достаточно исполнить `make clean`.

## Описание entry.S
[entry.S](entry.S) - определяет код, который будет исполняться до функции main. В этой лабораторной работе он довольно простой, но дальше он будет усложняться. Давайте разберём его step-by-step.

```assembly
.syntax unified

.section .text

.thumb_func
.global __reset_handler
__reset_handler:
    blx main
__halt:
	b __halt

.section .vector_table
.word __stack_start    // Initial SP
.word __reset_handler  // Reset Handler
```

- `.syntax unified` - директива, которая определяет тип синтаксиса файла. Для продвинутых, описание этой директивы подробнее можно посмотреть [здесь](https://sourceware.org/binutils/docs/as/ARM_002dInstruction_002dSet.html).
- `.section .text` - директива, которая определяет, что код ниже должен находиться в секции text. Как правило, в данной секции находится код программы.
- `.thumb_func` - директива, означает, что функция ниже написана в наборе инструкций типа Thumb. Для продвинутых, описание набора инструкций типа Thumb и ARM можно посмотреть [здесь](http://twins.ee.nctu.edu.tw/courses/ip_core_01/lab_hw_pdf/lab_1.pdf).
- `.global __reset_handler` - директива, означает, что символ(функция) `__reset_handler` должна быть видна из любой секции программы.
- `__reset_handler:` - определение символа `__reset_handler`.
- `blx main` - инструкция, которая перемещает текущее положение PC (Program Counter - адрес выполняемой команды) на символ `main`. Здесь и происходит вызов функции main.
- `b __halt` - инструкция, которая также перемещает текущее положение PC (Program Counter - адрес выполняемой команды) на символ `__halt`. Различие `B` и `BLX` можно посмотреть в [документации ARM](https://developer.arm.com/documentation/dui0489/h/arm-and-thumb-instructions/b--bl--bx--blx--and-bxj).
- `.section .vector_table` - определение секции vector_table. Данная секция содержит адрес начала стека `.word __stack_start`, адрес начального положения PC `.word __reset_handler` и адреса функций, который должны обрабатывать прерывания. Так как в нашей лабораторной нет прерываний, мы опустим их объявление. Символ `__reset_handler` определен выше, а символ `__stack_start` определен в линкер-скрипте.

## Описание линкер-скрипта
Как вы знаете, линкер объединяет входные файлы в один выходной файл. Выходной файл и каждый входной файл находятся в специальном формате данных, известном как ***формат объектного файла (.o)***. Каждый объектный файл имеет список секций (sections). Каждая секция в объектном файле имеет имя и размер. Некоторые секции имеют содержимое, например, секция .text хранит в себе код программы, секция .data хранит в себе данные программы. 

Каждая секция вывода имеет два адреса: VMA (Virtual Memory Adress) и LMA (Load Memory Adress). VMA - адрес, который секция будет иметь, во время исполнения выходного файла. LMA - адрес, по которому секция будет загружена. В большинстве случаев два адреса будут одинаковыми. Пример когда они могут отличаться, это когда раздел данных загружается во Flash-память, а затем копируется в SRAM-память при запуске программы. В этом случае адрес во Flash будет LMA, а адрес в SRAM будет VMA. Копирование это нужно, чтобы сохранить данные при выключении микроконтроллера. Когда микроконтроллер отключается от питания, все данные в SRAM стираются, а во Flash сохраняются.

Каждый объектный файл также имеет список символов, известный как таблица символов. Символы бывают определенными или неопределенными. У каждого символа есть имя, а у каждого определенного символа есть адрес. Если вы скомпилируете программу на C или C++ в объектный файл, то каждая функция, глобальная или статическая переменная получит определенный символ. А каждая неопределенная функция или глобальная переменная, на которые есть ссылка во входном файле, получат неопределенный символ. Задача линкера - собрать все символы со всех объектных файлов и определить все неопределенные символы. 

Давайте посмотрим на сгенерированные объектные файлы. Для этого выполните данные команды:
```
cd build
arm-none-eabi-objdump -t entry.o
```

Вы должны увидеть это:
```
SYMBOL TABLE:
00000000 l    d  .text  00000000 .text
00000000 l    d  .data  00000000 .data
00000000 l    d  .bss   00000000 .bss
00000004 l       .text  00000000 __halt
00000000 l    d  .vector_table  00000000 .vector_table
00000000 l    d  .ARM.attributes        00000000 .ARM.attributes
00000000 g     F .text  00000000 __reset_handler
00000000         *UND*  00000000 main
00000000         *UND*  00000000 __stack_start
```
Первый столбец - это значение символа. Оно у всех ноль, кроме символа `__halt`, потому что он расположен сразу после символа `__reset_handler:`, который из-за команды `blx main` имеет размер 4 байта. Второй столбец - флаги символов. Флаг l означает, что символ локальный и виден только из данного файла, g означает, что символ глобальный. Глобальным является только символ `__reset_handler`, потому что перед ним явно написана директива `.global` в файле [entry.S](entry.S). F означает, что символ является именем функции. d означает, что символ создан для отладки программы (debug). Третий столбец определяет секцию, в которой находится символ. `*UND*` означает, что секция не определена. Четвертый столбец - размер символа TODO ПОЧЕМУ РАЗМЕР `__reset_handle` РАВЕН 0. Последний столбец - это имя символа.

Линкер-скрипт управляет работой линкера. [entry.lds](entry.lds) - определяет как в конечной программе должны располагаться секции и определяет каким образом должна быть разделена память. Давайте рассмотрим этот скрипт step-by-step.

```assembly
ENTRY(__reset_handler);

FLASH_PADDR = 0x08000000;
FLASH_SIZE  = 0x00010000;
SRAM_PADDR  = 0x20000000;
SRAM_SIZE   = 0x00002000;

SECTIONS
{
    . = 0x00000000;

    .text : AT(ADDR(.text) + FLASH_PADDR)
    {
        KEEP(*(.vector_table));
        *(.text)
        *(.rodata)
    }

    __stack_start = SRAM_PADDR + SRAM_SIZE;
}
```

- `ENTRY(__reset_handler);` - определяет символ, с которого мы должны начать выполнение программы.
- FLASH_PADDR = 0x08000000;`` - константа. Адрес начала Flash-памяти. Значение этой константы должно совпадать с разделением памяти в STM32F051, которое можно посмотреть в [stm32f0xx_rm](docs/stm32f0xx_rm.pdf) на странице 45.
- `FLASH_SIZE  = 0x00010000;` - константа. Размер Flash-памяти. Для каждой программы размер Flash-памяти должен определяться отдельно.
- `SRAM_PADDR  = 0x20000000;` - константа. Адрес начала SRAM-памяти. Значение этой константы должно совпадать с разделением памяти в STM32F051.
- `SRAM_SIZE   = 0x00002000;` - константа. Размер SRAM-памяти. Для каждой программы размер SRAM-памяти должен определяться отдельно.
- `SECTIONS` - означает, что ниже будут описаны секции, которые должны быть в конечной программе.
- `. = 0x00000000;` - определение счетчик местоположения (location counte). Определяет на каком адресе мы сейчас находимся. Относительно него будут далее определяться адреса секций.
- `.text : AT(ADDR(.text) + FLASH_PADDR)` - означает, что мы определяем секцию .text, LMA которой равен ADDR(.text) + FLASH_PADDR = VMA адрес секции .text + 0x08000000. VMA адрес данной секции будет равен 0x00000000.
- `KEEP(*(.vector_table));` - далее в фигурных скобках перечисляется всё, что должно входить в секцию .text. `*(.vector_table)` означает, что в секцию .text должны входить все секции .vector_table входных файлов. KEEP() нужен для того, чтобы линкер-скрипт не оптимизировал эти секции и не удалил их.
- `*(.text)` - означает, что в секцию .text выходного файлы должны входить все секции .text входных файлов.
- `*(.rodata)` - аналогично.
- `__stack_start = SRAM_PADDR + SRAM_SIZE;` - определяет адрес символа адреса начала стека `__stack_start`.

Давайте посмотрим на результат работы линкер-скрипта. Для этого в папке build нужно выполнить следующую команду:
```
arm-none-eabi-objdump -t blinkled.elf
```
В ответе на команду нас не интересуют все строки, рассмотрим только следующие:
```
00000000 l    d  .text  00000000 .text
00000008 g     F .text  00000000 __reset_handler
0000000c l       .text  00000000 __halt
20002000 g       *ABS*  00000000 __stack_start
```
Согласно линкер-скрипту, по адресу 00000000 находится секция .text, в начале которой расположен `.vector_table`. А `.vector_table` в свою очередь состоит из `.word __stack_start` и `.word __reset_handler`. Тогда, по адресу 00000000 находится начальное положение стека, а по адресу 00000004 находится адрес функции `__reset_handler  `, в этом можно убедиться, если выполнть команду:
```
arm-none-eabi-objdump -t blinkled.elf
```
Ответом на команду будет дизассемблированный исполняемый файл:
```
00000000 <__reset_handler-0x8>:
   0:   20002000        .word   0x20002000
   4:   00000009        .word   0x00000009

00000008 <__reset_handler>:
   8:   f000 f88c       bl      124 <main>

0000000c <__halt>:
   c:   e7fe            b.n     c <__halt>
        ...
```
Видно, что значение `__stack_start` равно 0x20002000, что совпадает с выводом таблицы символов.

## Описание blinkled.c
Теперь мы можем приступить непосредственно к прогрммированию микроконтроллера. Самая главная концепция программирования STM32, которую нужно держать в голове - это то, что управление переферией контроллера происходит двумя способами:
- Специальный ассемблерные инструкции. В данной лабораторной работе мы не будем их касаться;
- Запись информации в специальные участки памяти, которые называются регистрами.

Именно изменяя информацию в регистрах можно управлять микроконтроллером. Рассмотрим для примера следующую команду, которая находится внизу файла [blinked.c](blinked.c):
```C
*(volatile uint32_t*)(uintptr_t)0x48000814U |=  0x100U;
```
Данная команда записывает единицу восьмой бит по адресу 0x48000814. Выставление единицы по этому адресу включает синий светодиод на отладочной плате! А вот следующая команда выключит тот же светодиод.
```C
*(volatile uint32_t*)(uintptr_t)0x48000814U &= ~0x100U;
```
Любой, владеющий булевой логикой и синтаксисом языка Си может убедиться сам, что данные команды действительно выставляют единицу и ноль в восьмом бите по адресу 0x48000814 и, что важно, не изменяют значение других битов.

Каким же образом мы определили, что восьмой бит по адресу 0x48000814 управляет состоянием синего светодиода на отладочной плате? Давайте заглянем в документацию!

Во-первых, скачайте Adobe Acrobat Reader, если вы этого еще не сделали или зарегестрируйтесь в онлайн версии. Далее, откройте документы из папки [docs](docs/) в Adobe Acrobat. Теперь заглянем в [stm32f0discovery](docs/stm32f0discovery.pdf). Мы выделили те строчки документации, которые понадобятся нам в этой лабораторной работе. Итак, в документации на плату написано:

> User LD4: Blue user LED connected to the I/O PC8 of the STM32F051R8T6. 

Значит, синий светодиод подключен к ножке микроконтроллера под названием PC8. В микроконтроллере много выходных ножек, для удобства их группируют. PC8 означает, что выходная ножка принадлежит к группе ножек С, ножка номер 8. Для удобства, группе ножек С будем обозначать GPIOC (General Purpose Input Output C).
Теперь заглянем в [stm32f0xx_rm](docs/stm32f0xx_rm.pdf). В списке всех комментариев вы можете увидеть вот такую табличку:

![imgs/GPIOC.png](imgs/GPIOC.png)

Значит, регистры, управляющие GPIOC находятся по адресу 0x48000800-0x48000BFF. Правее ссылка на описание всех управляющих регистров. Если перейти по ней, то можно увидеть огромную таблицу, в которой перечислены все биты, контролируюшие GPIOC. Нас интересуют биты, которые выставляют 0 или 1 на выходе ножки, они находятся в регистре GPIOx_ODR, где x - группа. Из таблицы мы видим, что offset у этого регистра = 0x14. Под offset подразумевается смещение относительно первого регистра, управляющего данной группой. В нашем случае это 0x48000800. Итого, получается 0x48000800 + 0x14 = 0x48000814, а это как раз тот самый регистр, в который мы записываем данные в нашей программе!

Теперь подробнее посмотрим на GPIOx_ODR. Перемотайте чуть выше до описание этого регистра, вы должны видеть это:
![imgs/GPIOx_ODR.png](imgs/GPIOx_ODR.png)

Здесь все просто, i-ый бит соответсвует i-ой ножке в группе ножек С. А значит мы должны менять 0x100 бит в 0x48000814, что мы и делаем в коде. Попробуйте самостоятельно изменить код так, чтобы мигал не синий, а зеленый светодиод. 

Чтобы подробнее познакомиться с GPIO советуем просмотреть главу 8 General-purpose I/Os (GPIO).

Теперь, когда мы посмотрели на примере как происходит управление микроконтроллером, мы можем понять что происходит в [blinked.c](blinked.c). Начнем с тактирования.

Чтобы понять что происходит дальше нужно обязательно посмотреть видео про [тактирование в STM32](https://www.youtube.com/watch?v=PP94Q0OYLkY&list=PLhtMaaf_npBzsEQ94eGn5RnuE-VdGVObR&index=5), без этого вы не поймете что происходит дальше.

Первое, что вызывается функцией main - это board_clocking_init():

```C
oid board_clocking_init()
{
    // (1) Clock HSE and wait for oscillations to setup.
    *REG_RCC_CR = 0x00010000U;
    while ((*REG_RCC_CR & 0x00020000U) != 0x00020000U);

    // (2) Configure PLL:
    // PREDIV output: HSE/2 = 4 MHz
    *REG_RCC_CFGR2 |= 1U;

    // (3) Select PREDIV output as PLL input (4 MHz):
    *REG_RCC_CFGR |= 0x00010000U;

    // (4) Set PLLMUL to 12:
    // SYSCLK frequency = 48 MHz
    *REG_RCC_CFGR |= (12U-1U) << 18U;

    // (5) Enable PLL:
    *REG_RCC_CR |= 0x01000000U;
    while ((*REG_RCC_CR & 0x02000000U) != 0x02000000U);

    // (6) Configure AHB frequency to 48 MHz:
    *REG_RCC_CFGR |= 0b000U << 4U;

    // (7) Select PLL as SYSCLK source:
    *REG_RCC_CFGR |= 0b10U;
    while ((*REG_RCC_CFGR & 0xCU) != 0x8U);

    // (8) Set APB frequency to 24 MHz
    *REG_RCC_CFGR |= 0b001U << 8U;
}
```
Здесь мы последовательно выставляем биты в нужных регистрах. (i) указывает на комментарий в документе [stm32f0xx_rm](docs/stm32f0xx_rm.pdf). Согласно этому документу и видео выше запускается тактирование на микроконтроллере.

Остановимся на функции board_gpio_init() и внимательно ее рассмотрим.

```C
void board_gpio_init()
{
    // (1) Enable GPIOC clocking:
    *REG_RCC_AHBENR |= 0x80000U;

    // (2) Configure PC8 mode:
    *GPIOC_MODER |= 0b01U << (2*8U);

    // (3) Configure PC8 type:
    *GPIOC_TYPER |= 0b0U << 8U;
}
```
- REG_RCC_AHBENR отвечает за



## Задачи к лабораторной №0
- [ ] Отрефакторить код (*в эмуляторе*):
	- [ ] В любой момент времени должно быть понятно, в какой бит какого регистра осуществляется запись.
	- [ ] Реализовать дефайны для всех бит регистров (см. документацию на микроконтроллер).
	- [ ] Реализовать макросы для записи значений в регистры.
- [ ] Моргать попеременно синим и зелёным диодами.
- [ ] Отправить сигнал SOS азбукой морзе с диода. **Зачем?**
- [ ] Со **звездой**: **Написать на ARM ассемблере timing-perfect delay. Доказать, что он точный, ссылаясь на документацию.** (*на железе*)
